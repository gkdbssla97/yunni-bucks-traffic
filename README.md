# ☕️ YUNNI-BUCKS-TRAFFIC
#### [YUNNI-BUCKS 프로젝트 세부 사항](https://github.com/gkdbssla97/yunni-bucks)

1. 개발 기간 : 2023-07 ~ 2022-09 *(MVP기능 구현 완료)* </br>
2. 개발 기간 : 2022-10 ~ *(트래픽 상황 대처 프로젝트 고도화)*
--- 

### Traffic 환경 동시성 처리
- 멀티 쓰레드 동작 중 발생 가능 문제점 해결 방안
  - 낙관 락(Optimistic Lock)
  - 비관 락(Pessimistic Lock)
  - 분산 락(Redisson, Distributed Lock)
--- 

### 기능 별 데이터 정합성 관리
- 메뉴 주문
- 쿠폰 관리
- 
---

### 메뉴 주문
#### 1. 한 사용자가 여러 개의 주문을 동시에 요청
- Optimistic Lock 활용
    #### 구현 이유
- Optimistic Locking 선택한 이유 
  - 대부분의 상황에서 실제로 동일한 리소스에 대한 동시 요청이 드물게 발생하고, 이런 상황에서는 Optimistic Locking이 더 효율적
  - 낮은 비용으로 높은 동시성을 제공하며, 충돌 발생 시 재시도 로직을 통해 처리
  

- Pessimistic Lock 사용하지 않은 이유
  - 다중 사용자가 아닌 한 명의 사용자 이므로 충돌이 자주 발생하거나, 데이터 일관성을 보장이 중요한 작업이라 판단하지 않았음


#### 2. 여러 사용자가 음료 A를 주문을 동시에 요청 *(해당 메뉴 재고 감소)*
- Pessimistic Lock 활용

> #### 시나리오
> 1. 100명의 사용자가 예기치 못하게 동시에 같은 Menu(Beverage)를 주문
> 2. 주문 당 해당 메뉴 주문 수량만큼 재고 감소
> 3. Pessimistic lock을 통해 주문 중 다른 사용자의 주문(Thread) 접근 제한
> 4. Thread 순차적으로 1번 ~ 100번 사용자 주문
>    1. `재고 - 주문 수량 >= 0` 일 경우 주문 완료
>    2. `재고 - 주문 수량 < 0` 일 경우 
>    *throw ExceptionControl.INSUFFICIENT_STOCK_QUANTITY.menuException();*

  #### 구현 이유
- Pessimistic Locking 선택한 이유
  - 주문 시스템에서는 동시에 여러 사용자가 같은 메뉴를 주문하는 경우, 그 메뉴의 재고 수량을 동시에 변경해야 하는 상황이 발생할 수 있다.
  - 비관적 락을 사용하면 한 번에 하나의 트랜잭션만 해당 메뉴의 재고를 변경할 수 있기 때문에 충돌을 방지할 수 있다.


- Optimistic Lock 사용하지 않은 이유
  - 낙관적 락은 충돌이 비교적 드물게 발생하는 상황에 유용하다. 
  - 주문 시스템의 경우 동시에 여러 사용자가 같은 메뉴를 주문하는 상황이 자주 발생하므로, 낙관적 락을 사용하면 충돌로 인한 롤백이 빈번하게 발생하여 오버헤드가 발생할거라 판단

  #### 생각해 보아야 할 점
- 나머지 스레드(사용자 별 주문 요청)들은 락이 해제될 때까지 대기 상태에 머무른다.
- 이 방식은 동시성 문제를 방지할 수 있지만, 대기 시간이 길어질 수 있다는 단점
- 대체 방안 분산 락?
- 최대 사용자는 몇 명까지인지 부하테스트 필요 (사용자가 늘어날수록 시간도 기하급수적 증가)
  - 10명: 564ms
  - 100명: 1sec 311ms
  - 1000명: 7sec 2ms
---

### 쿠폰 관리
- 신규 회원 가입 시 제공되는 선착순 쿠폰 100장 이벤트를 진행
    - Pessimistic Lock 활용
### 구현 이유

[//]: # (* PessimisticLock을 통한 비관적 lock 진행)

[//]: # (    * Redis를 사용하지 않은 이유)

[//]: # (        * 한 사람의 포인트에 관한 내용이기 때문에 대량의 트래픽이 걸리거나 많은 충돌이 발생하지 않을 것이라 판단하였기 때문이다.)

[//]: # (        * 한번에 한사람이 자신의 포인트 충전을 하는 것이기 때문.)

[//]: # (    * OptimisticLock을 사용하지 않은 이유)

[//]: # (        * Pessimistic Lock은 작업 도중에 Lock을 걸어 다른 쓰레드의 접근 자체를 차단하기 때문에 versioning을 통해 정합성을 맞추는 Optimistic Lock에 비해 데이터 정합성을 더 잘 보장할 수 있다고 생각했기 때문이다.)

[//]: # (            * 포인트의 경우는 실제 돈과 연결되기 때문에 정합성이 중요하다 판단하였다.)