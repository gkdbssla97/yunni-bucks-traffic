# ☕️ YUNNI-BUCKS-TRAFFIC
#### [YUNNI-BUCKS 프로젝트 세부 사항](https://github.com/gkdbssla97/yunni-bucks)

1. 개발 기간 : 2023-07 ~ 2022-09 *(MVP기능 구현 완료)* </br>
2. 개발 기간 : 2022-10 ~ *(트래픽 상황 대처 프로젝트 고도화)*
--- 

### Traffic 개요
#### 동시성 처리
- 멀티 쓰레드 동작 중 발생 가능 문제점 해결 방안
  - 낙관 락(Optimistic Lock)
  - 비관 락(Pessimistic Lock)
  - 분산 락(Redisson, Distributed Lock) (예정)
#### 성능 개선
- Redis Caching
- Redis zSet
---
### 기능 개선 및 정합성 관리
- 메뉴 주문
  - Optimistic Lock 활용
  - Pessimistic Lock 활용
- 선착순 쿠폰 발급
  - ()
- 조회
  - 전체 메뉴
    - Redis Cache 활용
  - 인기 메뉴
    - Redis zSet 활용
  
---

### 메뉴 주문
#### 1. 한 사용자가 여러 개의 주문을 동시에 요청
- Optimistic Lock 활용
    #### 구현 이유
- Optimistic Locking 선택한 이유 
  - 대부분의 상황에서 실제로 동일한 리소스에 대한 동시 요청이 드물게 발생하고, 이런 상황에서는 Optimistic Locking이 더 효율적
  - 낮은 비용으로 높은 동시성을 제공하며, 충돌 발생 시 재시도 로직을 통해 처리
  

- Pessimistic Lock 사용하지 않은 이유
  - 다중 사용자가 아닌 한 명의 사용자 이므로 충돌이 자주 발생하거나, 데이터 일관성을 보장이 중요한 작업이라 판단하지 않았음


#### 2. 여러 사용자가 음료 A를 주문을 동시에 요청 *(해당 메뉴 재고 감소)*
- Pessimistic Lock 활용

> #### 시나리오
> 1. 100명의 사용자가 예기치 못하게 동시에 같은 Menu(Beverage)를 주문
> 2. 주문 당 해당 메뉴 주문 수량만큼 재고 감소
> 3. Pessimistic lock을 통해 주문 중 다른 사용자의 주문(Thread) 접근 제한
> 4. Thread 순차적으로 1번 ~ 100번 사용자 주문
>    1. `재고 - 주문 수량 >= 0` 일 경우 주문 완료
>    2. `재고 - 주문 수량 < 0` 일 경우 
>    *throw ExceptionControl.INSUFFICIENT_STOCK_QUANTITY.menuException();*

  #### 구현 이유
- Pessimistic Locking 선택한 이유
  - 주문 시스템에서는 동시에 여러 사용자가 같은 메뉴를 주문하는 경우, 그 메뉴의 재고 수량을 동시에 변경해야 하는 상황이 발생할 수 있다.
  - 비관적 락을 사용하면 한 번에 하나의 트랜잭션만 해당 메뉴의 재고를 변경할 수 있기 때문에 충돌을 방지할 수 있다.


- Optimistic Lock 사용하지 않은 이유
  - 낙관적 락은 충돌이 비교적 드물게 발생하는 상황에 유용하다. 
  - 주문 시스템의 경우 동시에 여러 사용자가 같은 메뉴를 주문하는 상황이 자주 발생하므로, 낙관적 락을 사용하면 충돌로 인한 롤백이 빈번하게 발생하여 오버헤드가 발생할거라 판단

  #### 생각해 보아야 할 점
- 나머지 스레드(사용자 별 주문 요청)들은 락이 해제될 때까지 대기 상태에 머무른다.
- 이 방식은 동시성 문제를 방지할 수 있지만, 대기 시간이 길어질 수 있다는 단점
- 대체 방안 분산 락?
- 최대 사용자는 몇 명까지인지 부하테스트 필요 (사용자가 늘어날수록 시간도 기하급수적 증가)
  - 10명: 564ms
  - 100명: 1sec 311ms
  - 1000명: 7sec 2ms
---

### 메뉴 조회
#### 1. 사용자가 전체 메뉴를 조회한다.
- Redis Caching 활용
  - @Cacheable, Look-Aside Caching 전략
#### 구현 이유
- Redis Caching 선택한 이유
  - 높은 트래픽을 효율적으로 처리: 사용자가 전체 메뉴를 조회하는 경우, DB에 직접 접근하지 않고 Redis에 캐싱된 데이터를 사용하면, 응답 시간을 크게 단축시키고 DB에 가해지는 부하를 줄일 수 있다.
  - 일관된 사용자 경험 제공: 메뉴 정보는 자주 변경되지 않는 데이터라고 판단했다. Redis Caching을 사용하면, 사용자가 매번 동일한 데이터를 조회할 때 일관된 정보를 빠르게 제공할 수 있다.
  

- DB Lock 사용하지 않은 이유
  - 단순히 데이터를 조회하는 경우 (예: 메뉴 조회)와 같이 데이터의 변경이 없는 상황에서는 DB Lock 없이 Redis Caching만으로도 충분히 빠른 응답 시간과 효율적인 서버 운영

#### 적용 결과
<img src="https://github.com/gkdbssla97/yunni-bucks-traffic/assets/55674664/4f547d8a-2e8c-482c-a081-f02d71273be0" width="500" height="300">
<img src="https://github.com/gkdbssla97/yunni-bucks-traffic/assets/55674664/e5d4887e-4cd3-439b-bd86-c69859c9a99b" width="500" height="300">

| 구분             | TPS        | 응답시간(ms) |
|----------------|------------|---------|
| 레디스 캐싱 전략 사용 전 | 1247.75	   | 520.58  |
| 레디스 캐싱 전략 사용 후 | 2494.0     | 184.26  |
| 속도 개선 증가율       | 2.0배 (TPS) | 2.83배   |

DB 조회와 레디스 캐싱 조회 시 TPS 상승 및 응답시간이 DB 사용 대비 레디스 사용시 응답 시간은 약 2.83배 개선  

#### 2. 사용자가 인기 메뉴를 조회한다.
- Redis zSet 활용

> #### 시나리오
> 0. 특정 메뉴를 조회하면 조회수가 1만큼 증가한다.
> 1. 1000명의 사용자가 동시에 인기 메뉴를 조회한다. 
> 2. 1시간 동안 조회 수가 가장 높은 순으로 인기 메뉴를 조회한다.

#### 구현 이유
- Redis zSet 선택한 이유
  - 실시간 처리: Redis는 실시간으로 데이터를 처리한다. 메뉴의 조회수가 변경될 때마다 즉시 ZSET의 스코어를 업데이트할 수 있다.
  - 정렬 기능: zSet은 스코어에 따라 자동으로 메뉴를 정렬한다. 조회수를 Score로 사용하면, 인기 메뉴를 스코어가 높은 순서로 쉽게 조회할 수 있다고 판단했다.
  - 동시성 처리: Redis는 단일 스레드 모델을 사용하며, atomic operations를 지원한다. 따라서, 여러 사용자가 동시에 인기 메뉴를 조회하거나, 조회수를 업데이트하더라도 데이터의 일관성을 유지할 수 있다.
  

  #### 생각해 보아야 할 점
- Pageable 인자로 페이지 번호와 크기를 받아 특정 페이지의 메뉴를 조회하는 로직으로 특정 페이지 크기만큼의 메뉴가 Redis에 캐싱된다. 
- 처음 사용자A가 2 페이지를 조회하면 Pageable에 2 페이지 정보가 들어가고, 이 정보로 메뉴를 조회한 후 그 결과는 "Contents" 캐시에 저장된다.
- 만약 다른 사용자가 동일한 2 페이지를 조회하려고 하면, 이미 캐시에 저장된 정보를 불러와서 빠르게 응답할 수 있지만, 이 방법은 각 페이지마다 캐시를 따로 생성하므로, 메뉴 정보가 변경될 때마다 각 페이지의 캐시를 모두 업데이트해야 하는 문제가 있다.
- 메뉴 정보가 자주 변경되지 않는다면 전체 메뉴를 한 번에 캐싱하는 방식을 고려
---

### 쿠폰 관리
- 신규 회원 가입 시 제공되는 선착순 쿠폰 100장 이벤트를 진행
    - Pessimistic Lock 활용
### 구현 이유

[//]: # (* PessimisticLock을 통한 비관적 lock 진행)

[//]: # (    * Redis를 사용하지 않은 이유)

[//]: # (        * 한 사람의 포인트에 관한 내용이기 때문에 대량의 트래픽이 걸리거나 많은 충돌이 발생하지 않을 것이라 판단하였기 때문이다.)

[//]: # (        * 한번에 한사람이 자신의 포인트 충전을 하는 것이기 때문.)

[//]: # (    * OptimisticLock을 사용하지 않은 이유)

[//]: # (        * Pessimistic Lock은 작업 도중에 Lock을 걸어 다른 쓰레드의 접근 자체를 차단하기 때문에 versioning을 통해 정합성을 맞추는 Optimistic Lock에 비해 데이터 정합성을 더 잘 보장할 수 있다고 생각했기 때문이다.)

[//]: # (            * 포인트의 경우는 실제 돈과 연결되기 때문에 정합성이 중요하다 판단하였다.)
